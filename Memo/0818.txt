0818

오전 : git의 마무리
오후 : github시작

Detached HEAD
ㄴ detached 분리하다(부품같은)
ㄴ HEAD가 분리되서 보고싶던 커밋으로 가서 본다?
ㄴ 머리를 뽑아서 상태보러감
ㄴ 특정 커밋의 내용을 검토하거나,
ㄴ 특정 커밋 기반으로 새 브랜치를 만들 때 사용
ㄴ 새 브랜치 생성 : 보통 이전 커밋에서 새로운 작업을 시도해보고 싶을 때 사용
ㄴ 커밋 내역 둘러보기 : 그냥 머리 뽑아서 가서 보고 다시 원래 브랜치로 돌아와 헤드결합함.
ㄴ 근데 Detached HEAD 상태에서의 변경사항은 참조x, 시간이 지나면 GC에 의해 제거될 수 있음 -> 유지 : 브랜치새로생성해서, 체크인해줌
ㄴ git checkout (이동대상커밋의 고유번호7자리)
ㄴ git log해보면 HEAD의 위치가 바뀐걸 볼 수 있음
ㄴ 돌아오고 싶으면 그냥 마스터로 돌아오면된다
ㄴ HEAD를 뽑은 상태에서 브랜치 생성하면 실제로생성이됨
ㄴ 뽑은 상태에서 커밋하고싶으면 되도록 브랜치를 새로생성해서 거기에 커밋하도록
ㄴ git reset --hard master : 병합후 커밋하기전에 그냥 리셋하고싶을 때 사용
ㄴ 커밋 고유번호를 모르고, 현재 HEAD기준으로 이전, 이전, 이전,, 으로 이동할수있다
ㄴ git checkout HEAD~1 : 1단계 이전으로 이동
ㄴ 뒤에 숫자를 바꿔주면서 이동가능

git restore
ㄴ 저장하다!
ㄴ !주의 : 사용하면 되돌릴수없음
ㄴ add한 파일 add되돌리기가능 : git restore --staged (돌리고싶은파일명)
ㄴ 이거는 add상태는 돌려주지만 변경사항은 그냥 저장되버려서 git restore해도 원래대로 안돌아감
ㄴ 해결 : git restore --source (커밋해시번호) (대상파일명) -> HEAD가 이동하는게 아니라 헤드기준으로 그냥 파일 상태를 몇전을 바꿀거냐
ㄴ 이미 파일을 저장(add)하고 한참 후라면,
ㄴ git restore (돌리고싶은파일명)
ㄴ 이런 걸 쓰고싶다면 꼭 커밋! 을 해놓던가, 따로 백업파일을 만들어놓기!
ㄴ restore은 복구! 라는 의미가 강함
ㄴ git restore .
ㄴ 그냥 지금 당장 사용할 내용이 아니고 나중에 사용하려고 하는 거면 restore를 사용하지말고 stash를 사용하는게 맞다.
ㄴ 왜냐면 restore은 복구가 안되니까

git reset
ㄴ git reset (커밋해시번호)
ㄴ 이동하고 지정된 커밋이후 모든 커밋이 '사라지게'됨
ㄴ 긍까 어떤 커밋으로 이동하고 그 커밋 이후의 커밋 다 없애버림
ㄴ reset이라는 명령을 하는경우엔 reset --hard를 쓸 상황밖엔,,
ㄴ 신중하게 사용!
ㄴ 날려버리는 것!
ㄴ 근데 그 되돌리고 싶은 내용은 남아있음
ㄴ 커밋만 날려주는건가봐
ㄴ 내용도 날리고 싶다! -> 새로운 브랜치생성후 이동 -> 거기서 커밋! -> 새로운 브랜치에 커밋되면서 망친내용이 저장됨 그리고 마스터는 망친내용이 사라지면서 망치기 전으로 돌아옴
ㄴ reset --hard
ㄴ 작업 디렉토리의 내용까지 지정한 커밋의 내용으로 상태를 되돌립니다.
ㄴ 그냥 다. 날리는거 커밋도내용도
ㄴ 근데 되돌릴 단.한번의.기회를.줌.
ㄴ 리셋하고 커밋까진. 하지 않았다면.
ㄴ git reset --hard ORIG_HEAD

git revert
ㄴ revert : (본래 상태)되돌아가다
ㄴ reset vs revert
ㄴ 걍없애기 vs 새롭게 커밋을
ㄴ 이것도 협업용
ㄴ 돌아가고싶은 커밋을 현재위치로 땡겨옴
ㄴ 이전 커밋(히스토리)은 지켜주면서 새롭게도 할 수 있음
ㄴ 이렇게 안하면 깃허브에서 머지안해줌
ㄴ 에러가 안나서 좋은방법일듯
ㄴ 협업상황에서는 꼭 revert사용하기
ㄴ git revert (revert되고싶은파일의위치)
ㄴ 만약 git revert HEAD는 현재위치의 커밋을 바로 이전의 커밋으로 돌리겟다고 한것
ㄴ 엔터치면 vsc코드에 창이뜨면서 새롭게 커밋할 내용을 적으라함
ㄴ 적고나서 저장후 창을 닫으면 크라켄을 보면 바껴있는 것을 볼 수 있음
ㄴ ie 실수로 master에 커밋해버림 -> revert로 새롭게시작

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

Github
ㄴ push, pull로 코드파일을 관리가능
ㄴ 저장소의 주인이아닌사람이 저장소의 내용을 수정문의하는것 : Pull Request
ㄴ !무료!
ㄴ 로컬저장소와 원격저장소로 나뉨
ㄴ 로컬저장소 : git init, git clone
ㄴ 개발자 개인 컴퓨터에 위치한 저장소
ㄴ $ git init (또는 git clone)
ㄴ 원격저장소 : github, gitlab, bitbucket등등
ㄴ $ git push origin master
ㄴ 남이 깃허브에 올려놓은 코드들을 git clone으로 복제해서 가져와서 수정하든 리셋하든 아무거나 다 할 수 있음
ㄴ 그치만 이렇게 내가 변경한 내용들은 로컬저장소고 원래의 코드가 있는 원격저장소에는 영향이 가지 않는다
ㄴ 영향이 가게 하고싶다면 Pull Request하셈~
ㄴ 

push를 하기 위해서는 status가 클린해야함~
ㄴ 먼저 원격저장소를 등록!
ㄴ git romote add origin (url)
ㄴ url : 원격저장소주소(http)
ㄴ 대부분 기본이되는 저장소 이름을 origin이라함
ㄴ 등록된지 확인할라면
ㄴ git remote -v
ㄴ 2개 나옴 패치용 푸시용
ㄴ 그리고 이제 밀기!
ㄴ git push origin master
ㄴ git push -u origin emptylist : 한동안 emptylist에서 계속 작업을 할거다 라는 뜻 
ㄴ 저 작업 이후로는  같은 스트림에서 작업하는 동안에는 git push까지만 적어도 깃헙에 올라간다.(커밋이)

Amend vs Revert
ㄴ git commit --amend
ㄴ commit후에 수정,add 후에 --amend옵션 사용하면 커밋을 재작성 할 수 있다.
ㄴ 추가로 작업한 일이 작다고 하더라도 이전의 커밋을 완전히 새로 고쳐서 새 커밋으로 변경하는 것
ㄴ 장점 : 새 커밋으로 분리되지 않고 하나의 커밋으로 처리가능
ㄴ git reset : 커밋 취소하기
ㄴ git reset --hard
ㄴ git revert : 커밋 내용 되돌리기

ㄴ git commit --amend : 커밋 덮어쓰기
ㄴ 수정 후에 revert처럼 다시 커밋해줄 필요x

Q. revert에서는 바로 전 내용으로만 복구?
