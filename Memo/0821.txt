0821

오전 : 깃허브까지 마무리
오후 : 마무리 + java 시작!

git branch -M main
ㄴ -M이라는 옵션을 주면 master를 main으로 바꿔쓰기 가능
ㄴ 반대로도 가능

git branch
ㄴ git branch -r : 원격 저장소의 브랜치목록을 표시하는 데 사용됩니다.(-r : -remote)

작업이 진행될때 계속 push를 해줘야 편하다!

git push -u origin animals
ㄴ 후에 origin에 animals를 푸쉬하려면 git push만 작성해줘도 된다!
ㄴ 그리고 u옵션이 status할때마다 현재 상태를 알려주면서 도움말을 줌 좋음

git branch -r
ㄴ 지금 현재 원격 브랜치의 목록을 보여줌

만약 집이야. 라는 상황
ㄴ 클론 주소를 따와서 베시에 연결
ㄴ 클론주소를 따오는 당시의 원격저장소의 데이터를 다 받아오는 것임.
ㄴ git clone (url주소)
ㄴ git branch -r하면 원격저장소의  모든 목록이 다 보여짐
ㄴ 근데 git branch하면 main스트림만 나옴
ㄴ 이유는 클론하면 한번에 모든 브랜치들이 다 안옴
ㄴ 다른 스트림을 보고싶으면 detached상태로 가서 본다.
ㄴ 그러면 들여다본 폴더에 원래의 파일들이 있는 것을 볼 수 있음
ㄴ 이걸 가져오고싶다!
ㄴ 똑같은 이름의 브랜치를 생성해야함
ㄴ 그럼 그대로 다 가져올 수 있음
ㄴ 이 과정은 어쩔 수 없다.
ㄴ 기존의 원격저장소의 내용은 있지만 로컬에 모든 내용이오지를 않음(= 브랜치들이 다 생성되지 않음)
ㄴ 여기까지 FM
ㄴ ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
ㄴ 더 쉬운 방법은!
ㄴ 그냥 클론으로 받은 후
ㄴ 받아진 폴더로 이동한 후에
ㄴ 바로 이동하고싶은 브랜치로 이동하면 된다!
ㄴ 이동하면 자동으로 브랜치가 가져와짐
ㄴ 원격저장소를 자동으로 추척해서 가져와준다! 짱!
ㄴ 한번 집에서 받은 클론은 계속 클론해줄필요없고
ㄴ 동기화를 해주면 된다

동기화 (Fetch & Pull)
ㄴ 항상 원격과 로컬을 비교해서 동기화가 됬는지 확인을 한 후에 작업을 진행해줘야 한다!(pull)
ㄴ fetch는 좀 약하고 pull이 좀 쎈건데
ㄴ fetch : 최신 데이터(변경사항)를 가져오기만함, 로컬에 반영을 하진않음 그리고 머지함.(안전한 방법)
ㄴ 로컬과 원격끼리 차이나는 데이터들을 가져온다
ㄴ git fetch (저장한 원격저장소의 이름)
ㄴ 근데 저장소 이름 생략하면 origin을 가져옴
ㄴ 실제로 땡겨오면 코드만 땡겨온거고 실제로 파일이 변하거나 반영되진 않음
ㄴ 반영하고싶다면
ㄴ git checkout 가고싶던저장소브랜치이름
ㄴ 코드가져온거임
ㄴ git pull (origin/animals : 저장소브랜치이름)
ㄴ 이러면 진짜로 로컬로 변경사항들을 가져온거임
ㄴ 이런식으로 하면 처음에만 클론받고 계속 동기화 할 수있
ㄴ 권장방법 : fetch후 pull
ㄴ 많이 쓰는 방법 : 그냥 pull
ㄴ 자잘자잘한 pull권유가 원활한 진행에 조타
ㄴ pull = fetch+merge
ㄴ !pull을 실행할 때는 현재 브랜치위치가 변경된다는 점을 주의해야한다!
ㄴ pull하기 전에 커밋하거나 stash를 해야한다!

Git pull과 충돌(Conflict)
ㄴ 패치하고 풀하고 수정 후 커밋

Collaborator
ㄴ 나 이외의 다른사람이 내 깃허브에 push할 수 있는 권한부여(=주인의 소유권에 관한것들은 못함)
ㄴ 회사에서는 잘 안함
ㄴ 그럼 push어캄
ㄴ pull request 요청함
ㄴ 어쨋든 collaborator추가하려면 레파지토리설정가서해라

README.md파일
ㄴ md : mark-down
ㄴ html은 hyper-text-markup-language 초월문서(그냥의 텍스트에 기능을 부여해서 텍스트만의 기능을 초월했다. 문서의 기능을 뛰어넘었따.)
ㄴ readme파일을 꼭 넣어주는 것이 좋다
ㄴ 왜 mark-down이냐 : mark-up보단 간결하고 복잡하진않지만 쓰기 귀찬음
ㄴ 결론적으로 readme파일을 md형식으로 쓰는걸 권장한다~ 라는 뜻임
ㄴ 노션도 md형식을 가짐
ㄴ readme파일로 그 저장소의 용도를 설명을 하는 것!
ㄴ 간단하게라도 작성하는 것을 추천!

Git Workflow(협업용)
ㄴ centralized-workflow(중앙집중형 워크플로우) : 모든 개발자가 하나의 브랜치에 계속 올리는 방법/ 안좋음->master브랜치 하나에 다 올리고 다 수정하는느낌,부작용多
ㄴ 해결 : Feature-Branch-Workflow
ㄴ 여태까지 배웠던 방법의 다수의 branch를 이용한 개발
ㄴ git Flow. 라고부름
ㄴ master(저장용), develop(말그대로),feature(기술들 feat/login), release(배포용), hotfixes(급하게 수정),,,
ㄴ master와 develop이 제일 오래감
ㄴ ux공작소에 검색해ㅂ
ㄴ master 브랜치를 건들지X! 안정된 버전만이 기록되어야함(merge), 항상 최신이여야함

Pull Request & Fork
ㄴ pull 요청! : pr이라고도함. 
ㄴ Forking : 다른 사람의 원격 레포지토리를 자신의 GitHub 계정으로 복제하는 것을 말합니다.
ㄴ 포크모양 누르면 내꺼로 가져와짐
ㄴ 원본 저장소에는 영향이 없다!
ㄴ 그리고 맘대로 수정 생성 다 가능
ㄴ 하고 만약 원작성자에게 pull request를 하고싶다면
ㄴ 깃허브 페이지에서 pull request를 누르면됨
ㄴ 하고 기다리기~

JAVA
ㄴ 컴파일러 사용. JS가 인터프리터
ㄴ 컴파일러는 한페이지를 통으로 번역해줘서 처음은 늦음. 그 후에 컴파일은 빠름
ㄴ 인터프리터는 한줄한줄 번역해줌
ㄴ 자바는 컴파일러를 사용한다!
ㄴ 컴파일러가 2진 파일(클래스 파일)로 변경해줌
ㄴ 정적 타이핑 언어

변수
ㄴ int
ㄴ 4 byte의 정수형을 답는 변수이다.

Java(eclipse)
ㄴ 자바는 main함수부터 시작한다.
ㄴ 저장은 습관처럼!
ㄴ







Q. origin원격저장소를 이미 사용했었는데 그냥 이름뿐인건가
새로운 레파지토리여서 상관x인지 각각의 레파지토리를 열때마다 처음 만드는 원격저장소를 orgin이라고 하는건지
Q. 근데 -u옵션을 한번 주면 그 폴더전체에 적용되는지